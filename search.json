[
  {
    "objectID": "QuantumToolbox.jl/time_evolution/rabi.html",
    "href": "QuantumToolbox.jl/time_evolution/rabi.html",
    "title": "Vacuum Rabi oscillation",
    "section": "",
    "text": "Inspirations taken from this QuTiP tutorial by J.R. Johansson, P.D. Nation, and C. Staufenbiel\nIn this notebook, the usage of QuantumToolbox.sesolve and QuantumToolbox.mesolve will be demonstrated with Jaynes-Cummings model (JC model) to observe Rabi oscillations in the isolated case and the dissipative case. In the dissipative case, a bosonic interacts with the cavity and the two-level atom in the JC model."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/rabi.html#introduction-to-jaynes-cumming-model",
    "href": "QuantumToolbox.jl/time_evolution/rabi.html#introduction-to-jaynes-cumming-model",
    "title": "Vacuum Rabi oscillation",
    "section": "Introduction to Jaynes-Cumming model",
    "text": "Introduction to Jaynes-Cumming model\nThe JC model is a simplest quantum mechanical model for light-matter interaction, describing an atom interacting with an external electromagnetic field. To simplify the interaction, the JC model considers a two-level atom interacting with a single bosonic mode, which can also be thought of as a single-mode cavity.\nThe Hamiltonian of JC model is given by\n\\[\n\\hat{H}_\\text{tot} = \\hat{H}_{\\text{a}} + \\hat{H}_{\\text{c}} + \\hat{H}_{\\text{int}}\n\\]\nwhere\n\n\\(\\hat{H}_{\\text{a}} = \\frac{\\omega_\\text{a}}{2} \\hat{\\sigma}_z\\): Hamiltonian for atom alone\n\\(\\hat{H}_{\\text{c}} = \\omega_\\text{c} \\hat{a}^\\dagger \\hat{a}\\): Hamiltonian for cavity alone\n\\(\\hat{H}_{\\text{int}} = \\Omega \\left( \\hat{\\sigma}^\\dagger + \\hat{\\sigma} \\right) \\cdot \\left( \\hat{a}^\\dagger + \\hat{a} \\right)\\): Interaction Hamiltonian for coherent interaction\n\nwith\n\n\\(\\omega_\\text{a}\\): Frequency of the two-level atom\n\\(\\omega_\\text{c}\\): Frequency of the cavity’s electromagnetic mode\n\\(\\Omega\\) : Coupling strength between the atom and the cavity\n\\(\\hat{\\sigma}_z\\) : Pauli-\\(Z\\) matrix. Equivalent to \\(|e\\rangle\\langle e| - |g\\rangle\\langle g|\\)\n\\(\\hat{a}\\) : Annihilation operator of single-mode cavity \n\\(\\hat{\\sigma}\\) : Lowering operator of atom. Equivalent to \\(|g\\rangle\\langle e|\\)\n\nBy applying the rotating wave approximation (RWA), the counter rotating terms (\\(\\hat{\\sigma} \\cdot \\hat{a}\\) and its Hermitian conjugate) are ignored, yielding\n\\[\n\\hat{H}_\\text{tot} \\approx \\hat{H}_{\\text{a}} + \\hat{H}_{\\text{c}} + \\Omega \\left( \\hat{\\sigma} \\cdot \\hat{a}^\\dagger + \\hat{\\sigma}^\\dagger \\cdot \\hat{a} \\right)\n\\]\n\nUsage of QuantumToolbox for JC model in general\n\nimport:\n\nimport QuantumToolbox: sigmaz, sigmam, destroy, qeye, basis, fock, \n    ⊗, n_thermal, sesolve, mesolve\nimport CairoMakie: Figure, Axis, lines!, axislegend, xlims!, display, @L_str\n\n\nN = 2 # Fock space truncated dimension\n\nωa = 1\nωc = 1 * ωa    # considering cavity and atom are in resonance\nσz = sigmaz() ⊗ qeye(N) # order of tensor product should be consistent throughout\na  = qeye(2)  ⊗ destroy(N)  \nΩ  = 0.05\nσ  = sigmam() ⊗ qeye(N)\n\nHa = ωa / 2 * σz\nHc = ωc * a' * a # the symbol `'` after a `QuantumObject` act as adjoint\nHint = Ω * (σ * a' + σ' * a)\n\nHtot  = Ha + Hc + Hint\n\nprint(Htot)\n\n\nQuantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true\n4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 6 stored entries:\n  0.5+0.0im      ⋅           ⋅      0.05+0.0im\n      ⋅      1.5+0.0im       ⋅           ⋅    \n      ⋅          ⋅      -0.5+0.0im       ⋅    \n 0.05+0.0im      ⋅           ⋅       0.5+0.0im"
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/rabi.html#isolated-case",
    "href": "QuantumToolbox.jl/time_evolution/rabi.html#isolated-case",
    "title": "Vacuum Rabi oscillation",
    "section": "Isolated case",
    "text": "Isolated case\nFor the case of the JC model being isolated, i.e., with no interaction with the surrounding environment, the time evolution is governed solely by the Schrödinger equation, \\(\\hat{H}|\\psi(t)\\rangle = \\partial_t|\\psi(t)\\rangle\\). The QuantumToolbox.sesolve function is ideal for simulating such pure state evolution.\nFor the context of Rabi problem, we set the initial state as \\(\\psi_0 = |e\\rangle \\otimes |0\\rangle\\), where \\(|e\\rangle\\) is the excited state of the atom and \\(|0\\rangle\\) is the vacuum state of the cavity.\n\ne_ket = basis(2,0) \nψ0 = e_ket ⊗ fock(N, 0)\n\ntlist = 0:2.5:1000 # a list of time points of interest\n\n# define a list of operators whose expectation value dynamics exhibit Rabi oscillation\neop_ls = [\n    a' * a,                      # number operator of cavity\n    (e_ket * e_ket') ⊗ qeye(N), # excited state population in atom\n]\n\nsol = sesolve(Htot , ψ0, tlist; e_ops = eop_ls)\nprint(sol)\n\nProgress: [                              ]   0.2% --- Elapsed Time: 0h 00m 02s (ETA: 0h 13m 20s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 00s)\nSolution of time evolution\n(return code: Success)\n--------------------------\nnum_states = 1\nnum_expect = 2\nODE alg.: OrdinaryDiffEqTsit5.Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false))\nabstol = 1.0e-8\nreltol = 1.0e-6\n\n\nCompare the dynamics of \\(| e \\rangle\\langle e|\\) alongside \\(a^\\dagger a\\)\n\nn = real.(sol.expect[1, :])\ne = real.(sol.expect[2, :])\nfig_se = Figure(size = (600, 350))\nax_se = Axis(\n    fig_se[1, 1],\n    xlabel = L\"time $[1/\\omega_a]$\", \n    ylabel = \"expectation value\", \n    xlabelsize = 15, \n    ylabelsize = 15,\n    width = 400,\n    height = 220\n)\nxlims!(ax_se, 0, 400)\nlines!(ax_se, tlist, n, label = L\"$\\langle a^\\dagger a \\rangle$\")\nlines!(ax_se, tlist, e, label = L\"$P_e$\")\naxislegend(ax_se; position = :rt, labelsize = 15)\ndisplay(fig_se);\n\n\n\n\n\n\n\n\nIn the above plot, the behaviour of the energy exchange between the atom and the cavity is clearly visible, addressing the Rabi problem."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/rabi.html#dissipative-case",
    "href": "QuantumToolbox.jl/time_evolution/rabi.html#dissipative-case",
    "title": "Vacuum Rabi oscillation",
    "section": "Dissipative case",
    "text": "Dissipative case\nIn contrast to isolated evolution, a realistic system interacts with its surrounding environment, leading to energy or particle exchange. Here, we focus on observing the Rabi oscillations of the JC model with the inclusion of interactions with an external environment at some finite temperature.\nWe start by reviewing the interaction Hamiltonians between the thermal field and atom/cavity\n\nAtom: \\[\n      \\hat{H}_{\\text{a}}^\\text{int} = \\sum_l \\alpha_l \\left( \\hat{b}_l + \\hat{b}_l^\\dagger \\right) \\left( \\hat{\\sigma} + \\hat{\\sigma}^\\dagger \\right)\n      \\]\nCavity: \\[\n      \\hat{H}_{\\text{c}}^\\text{int} = \\sum_l \\beta_l \\left( \\hat{b}_l + \\hat{b}_l^\\dagger \\right) \\left( \\hat{a} + \\hat{a}^\\dagger \\right)\n      \\]\n\nwhere for the \\(l\\)-th mode\n\n\\(\\alpha_l\\) is the coupling strength with the atom\n\\(\\beta_l\\) is the coupling strength with the cavity\n\\(\\hat{b}_l\\) is the annihilation operator\n\nBy applying the aforementioned RWA and following the standard procedure of the Born-Markovian approximation, we obtain \\(\\kappa\\), the cavity dissipation rate, and \\(\\gamma\\), the atom dissipation rate. Consequently, the time evolution of the dissipative JC model is described by the Lindblad master equation.\n\\[\n\\dot{\\hat{\\rho}} = -\\frac{i}{\\hbar} [\\hat{H}, \\hat{\\rho}] + \\sum_{i = 1}^4 \\mathcal{D}[\\sqrt{\\Gamma_i} \\hat{S}_i]\\left(\\hat{\\rho}\\right)\n\\]\nwhere \\(\\sqrt{\\Gamma_i} \\hat{S}_i\\) are the collapse operators, given by\n\n\n\n\\(i\\)\n\\(\\Gamma_i\\)\n\\(\\hat{S}_i\\)\n\n\n\n\n1\n\\(\\kappa \\cdot n(\\omega_c, T)\\)\n\\(\\hat{a}^\\dagger\\)\n\n\n2\n\\(\\kappa \\cdot [1 + n(\\omega_c, T)]\\)\n\\(\\hat{a}\\)\n\n\n3\n\\(\\gamma \\cdot n(\\omega_a, T)\\)\n\\(\\hat{\\sigma}^\\dagger\\)\n\n\n4\n\\(\\gamma \\cdot [1 + n(\\omega_a, T)]\\)\n\\(\\hat{\\sigma}\\)\n\n\n\nwith \\(n(\\omega, T)\\) being the Bose-Einstein distribution of the thermal field and \\[\n\\mathcal{D}[\\hat{\\mathcal{O}}]\\left(\\cdot\\right) = \\hat{\\mathcal{O}} \\left(\\cdot\\right) \\hat{\\mathcal{O}}^\\dagger - \\frac{1}{2} \\{ \\hat{\\mathcal{O}}^\\dagger \\hat{\\mathcal{O}}, \\cdot \\}\n\\] being the Lindblad dissipator.\n\nSolve for evolutions in dissipative case\nWe can now define variables in julia and solve the evolution of dissipative JC model\n\n# Collapse operators for interaction with the environment with variable dissipation rates \n# and thermal energy of the environment. `n_thermal()` gives Bose-Einstein distribution\ncop_ls(_γ, _κ, _KT) = (\n    √(_κ * n_thermal(ωc, _KT)) * a', \n    √(_κ * (1 + n_thermal(ωc, _KT))) * a, \n    √(_γ * n_thermal(ωa, _KT)) * σ', \n    √(_γ * (1 + n_thermal(ωa, _KT))) * σ, \n)\n\ncop_ls (generic function with 1 method)\n\n\n\n# use the same ψ0, tlist, and eop_ls from isolated case\nγ = 4e-3\nκ = 7e-3\nKT = 0 # thermal field at zero temperature\n\n# `mesolve()` only has one additional keyword argument `c_ops` from `sesolve()`\nsol_me  = mesolve(Htot,  ψ0, tlist, cop_ls(γ, κ, KT), e_ops = eop_ls)\n\nprint(sol_me)\n\nProgress: [                              ]   0.2% --- Elapsed Time: 0h 00m 01s (ETA: 0h 06m 40s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 00s)\nSolution of time evolution\n(return code: Success)\n--------------------------\nnum_states = 1\nnum_expect = 2\nODE alg.: OrdinaryDiffEqTsit5.Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false))\nabstol = 1.0e-8\nreltol = 1.0e-6\n\n\n\nn_me = real.(sol_me.expect[1, :])\ne_me = real.(sol_me.expect[2, :])\n\nfig_me = Figure(size = (600, 350))\nax_me = Axis(\n    fig_me[1, 1],\n    xlabel = L\"time $[1/\\omega_a]$\", \n    ylabel = \"expectation value\", \n    xlabelsize = 15, \n    ylabelsize = 15,\n    width = 400,\n    height = 220\n)\nlines!(ax_me, tlist, n_me, label = L\"\\langle a^\\dagger a \\rangle\")\nlines!(ax_me, tlist, e_me, label = L\"$P_e$\")\naxislegend(ax_me; position = :rt, labelsize = 15)\ndisplay(fig_me);\n\n\n\n\n\n\n\n\nFrom the above example, one can see that the dissipative system is losing energy over time and asymptoting to zero. We can further consider the thermal field with finite temperature.\n\nsol_me_  = mesolve(Htot,  ψ0, tlist, cop_ls(γ, κ, 0.3 * ωa), e_ops = eop_ls) # replace KT with finite temperature\n\nn_me_ = real.(sol_me_.expect[1, :])\ne_me_ = real.(sol_me_.expect[2, :])\nfig_me_ = Figure(size = (600, 350))\nax_me_ = Axis(\n    fig_me_[1, 1],\n    xlabel = L\"time $[1/\\omega_a]$\", \n    ylabel = \"expectation value\", \n    xlabelsize = 15, \n    ylabelsize = 15,\n    width = 400,\n    height = 220\n)\nlines!(ax_me_, tlist, n_me_, label = L\"\\langle a^\\dagger a \\rangle\")\nlines!(ax_me_, tlist, e_me_, label = L\"$P_e$\")\naxislegend(ax_me_; position = :rt, labelsize = 15)\ndisplay(fig_me_);\n\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\n\n\n\n\n\n\n\nDespite the persistence of the asymptotic behaviour, the system no longer approaches zero but instead reaches a steady-state above zero. This indicates that the system has been thermalized by the environment."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/rabi.html#version-information",
    "href": "QuantumToolbox.jl/time_evolution/rabi.html#version-information",
    "title": "Vacuum Rabi oscillation",
    "section": "Version Information",
    "text": "Version Information\n\nimport QuantumToolbox\nQuantumToolbox.versioninfo()\n\n\n QuantumToolbox.jl: Quantum Toolbox in Julia\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2022 and later.\nCurrent admin team:\n    Alberto Mercurio and Yi-Te Huang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/fluorescence.html",
    "href": "QuantumToolbox.jl/time_evolution/fluorescence.html",
    "title": "Resonance fluorescence",
    "section": "",
    "text": "Inspirations taken from this QuTiP tutorial by J. R. Johansson.\nIn this tutorial, we demonstrate the following functionalities:\nwith the example of resonance fluorescence in the weak field limit. We also adopt the convention \\(\\hbar = 1\\) throughout this tutorial."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/fluorescence.html#introduction",
    "href": "QuantumToolbox.jl/time_evolution/fluorescence.html#introduction",
    "title": "Resonance fluorescence",
    "section": "Introduction",
    "text": "Introduction\nResonance fluorescence is the radiative behavior of a two-level atom driven by a resonant light mode in a coherent state (usually a monochromatic laser beam). The Hamiltonian \\(H\\) is given by\n\n\\(H_\\text{a} = \\frac{\\omega_a}{2} \\hat{\\sigma}_z\\)\n\\(H_\\text{drv} = \\Omega \\cos(\\omega_L t) (\\hat{\\sigma}^{+} + \\hat{\\sigma}^{-})\\)\n\nwith\n\n\\(\\omega_a\\): Frequency of the two-level atom\n\\(\\omega_L\\): Frequency of the light field\n\\(\\Omega\\): Field strength of the light field\n\\(\\hat{\\sigma}_{x,y,z}\\): Pauli matrices\n\\(\\hat{\\sigma}^{\\pm}\\): Raising (\\(+\\)) and lowering (\\(-\\)) operators, equivalent to \\(|e\\rangle\\langle g|\\) and \\(|g\\rangle\\langle e|\\) respectively\n\nTo simplify the problem, we consider the total Hamiltonian (in the rotating frame)\n\\[  \nH^\\text{rot} = U^\\dagger H_\\text{a} U + U^\\dagger H_\\text{drv} U -i U^\\dagger \\frac{d}{dt} U,  \n\\]\nwhere the unitary operator is given by \\(U = e^{-i \\omega_L t \\cdot \\hat{\\sigma}_z}\\). The third term of \\(H^\\text{rot}\\) is simply \\(-\\frac{\\omega_L}{2}\\hat{\\sigma}_z\\), and the first and second terms are evaluated as:\n\\[\nU^\\dagger H_\\text{a} U = \\frac{\\omega_a}{2}\\hat{\\sigma}_z,\n\\] \\[\nU^\\dagger H_\\text{drv} U = \\Omega \\cos(\\omega_L t) \\Big[e^{i\\omega_L t}\\hat{\\sigma}^{+} + e^{-i\\omega_L t}\\hat{\\sigma}^{-}\\Big].\n\\]\nIn the weak field limit, where \\(\\Omega/\\omega_L \\ll 1\\), we can drop the time-dependent part in the rotating frame through rotating-wave approximation (RWA). First, we expand \\(\\cos(\\omega_L t)\\) to its exponential form, \\[\n\\Omega \\cos(\\omega_L t) \\Big[e^{i\\omega_L t}\\hat{\\sigma}^{+} + e^{-i\\omega_L t}\\hat{\\sigma}^{-}\\Big] = \\frac{\\Omega}{2}\\Big[(1 + e^{2i\\omega_L t})\\hat{\\sigma}^{+} + (1 + e^{-2i\\omega_L t})\\hat{\\sigma}^{-}\\Big]\n\\] The time-dependent parts with frequency \\(2\\omega_L\\) are dropped, yielding \\[\nH^\\text{rot} \\simeq \\frac{\\omega_a}{2} \\hat{\\sigma}_z + \\frac{\\Omega}{2} \\hat{\\sigma}_x - \\frac{\\omega_L}{2} \\hat{\\sigma}_z = \\frac{\\Delta}{2} \\hat{\\sigma}_z + \\frac{\\Omega}{2} \\hat{\\sigma}_x\n\\] where \\(\\Delta \\equiv \\omega_a - \\omega_L\\) is the detuning between the two-level atom and the driving light. In the realistic near-resonance case \\(\\Delta \\simeq 0\\), characteristic of the radiative behaviour remains. Thus, for the following demonstration, we only consider the exact resonance \\(\\Delta = 0\\).\n\nDissipation dynamics\nWe start by the interaction Hamiltonian between the thermal field and atom \\[\n\\hat{H}_{\\text{a}}^\\text{int} = \\sum_l \\alpha_l \\left( \\hat{b}_l + \\hat{b}_l^\\dagger \\right) \\left( \\hat{\\sigma}^{-} + \\hat{\\sigma}^{+} \\right)\n\\] where for the \\(l\\)-th mode\n\n\\(\\alpha_l\\) is the coupling strength with the atom\n\\(\\hat{b}_l\\) is the annihilation operator\n\nBy applying rotating wave approximation (RWA) and following the standard procedure of the Born-Markovian approximation, we obtain the atom dissipation rate \\(\\gamma_0\\). Consequently, the dynamics is described by the Lindblad master equation. \\[\n\\mathcal{L} = \\gamma_0 n(\\omega_a, T) \\mathcal{D}[\\hat{\\sigma}^{+}] + \\gamma_0 [1 + n(\\omega_a, T)] \\mathcal{D}[\\hat{\\sigma}^{-}]\n\\]\nwhere\n\n\\(n(\\omega, T)\\): Bose-Einstein distribution of the thermal field at temperature \\(T\\)\n\\(\\mathcal{D}[\\cdot]\\): The Lindblad dissipator (has exactly the same expression in the lab frame and the rotating frame)"
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/fluorescence.html#code-demonstration",
    "href": "QuantumToolbox.jl/time_evolution/fluorescence.html#code-demonstration",
    "title": "Resonance fluorescence",
    "section": "Code Demonstration",
    "text": "Code Demonstration\n\n\nusing QuantumToolbox\nimport CairoMakie: Figure, Axis, @L_str, lines!, axislegend, display, ylims!, xlims!\n\n\nΩ = 1\nγ0 = 0.05 * Ω\nKT = 0 # thermal field at zero temperature  \n\n0\n\n\nWe define a function that returns the Liouvillian SuperOperator of the system.\n\nfunction liouvillian_spec(_Ω, _γ0, _KT)\n    H = _Ω/2 * sigmax()\n    c_ops = [\n        √(_γ0 * n_thermal(_Ω, _KT)) * sigmap(),\n        √(_γ0 * (1 + n_thermal(_Ω, _KT))) * sigmam(),\n    ]\n    return liouvillian(H, c_ops)    \nend\n\nliouvillian_spec (generic function with 1 method)\n\n\nWe first use mesolve to solve the master equation with several observables given in e_ops.\n\ne_ket = basis(2,0)\ne_ops = [\n    sigmax(),\n    sigmay(),\n    sigmaz(),\n    sigmam(),\n    sigmap(),\n    e_ket * e_ket'\n]\nψ0 = e_ket # set initial state being purely excited to better observe the radiative behaviour\nL = liouvillian_spec(Ω, γ0, KT)\nprint(L)\n\n\nQuantum Object:   type=SuperOperator   dims=[2]   size=(4, 4)\n4×4 SparseMatrixCSC{ComplexF64, Int64} with 12 stored entries:\n -0.05+0.0im     0.0-0.5im     0.0+0.5im      ⋅    \n   0.0-0.5im  -0.025+0.0im         ⋅      0.0+0.5im\n   0.0+0.5im         ⋅      -0.025+0.0im  0.0-0.5im\n  0.05+0.0im     0.0+0.5im     0.0-0.5im      ⋅    \n\n\nWe already generate the Liouvillian with c_ops included above. We don’t need to specify the c_ops again in mesolve:\n\ntlist = 0:0.1:20  \nsol = mesolve(L, ψ0, tlist, nothing, e_ops = e_ops)\n\nProgress: [                              ]   0.5% --- Elapsed Time: 0h 00m 02s (ETA: 0h 06m 40s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 00s)\n\n\nSolution of time evolution\n(return code: Success)\n--------------------------\nnum_states = 1\nnum_expect = 6\nODE alg.: OrdinaryDiffEqTsit5.Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false))\nabstol = 1.0e-8\nreltol = 1.0e-6\n\n\nBy observing the expectation values of the Pauli operators, we see that the Bloch vector \\((\\langle \\hat{\\sigma}_x \\rangle, \\langle \\hat{\\sigma}_y \\rangle, \\langle \\hat{\\sigma}_z \\rangle)\\) becomes shorter over time, which is consistent with the dissipative behaviour. Also, the population of the excited state \\(|e\\rangle\\) has an oscillation amplitude decaying over time.\n\nexpect = real.(sol.expect)\nfig1 = Figure(size = (600,300))\nax11 = Axis(\n    fig1[1,1]\n)\nlines!(ax11, tlist, expect[1,:], label = L\"\\langle \\hat{\\sigma}_x \\rangle\")\nlines!(ax11, tlist, expect[2,:], label = L\"\\langle \\hat{\\sigma}_y \\rangle\")\nlines!(ax11, tlist, expect[3,:], label = L\"\\langle \\hat{\\sigma}_z \\rangle\")\naxislegend(ax11)\nylims!(ax11, (-1,1))\n\nax12 = Axis(\n    fig1[2,1],\n    xlabel = L\"time $[1/\\Omega]$\"\n)\nlines!(ax12, tlist, expect[6,:], label = L\"P_e\")\naxislegend(ax12)\nylims!(ax12, (0,1))\n\ndisplay(fig1);\n\n\n\n\n\n\n\n\nFurther, we check the effect of different values of the damping rate. Note that despite these dissipation rates looked enormous at first glance, it is still to the order of the field strength and therefore considered dissipative for the system in the lab frame.\n\nresults = []\nγ0s = Ω .* [0.1, 0.5, 1]\nfor γ0 in γ0s\n    result = mesolve(liouvillian_spec(Ω, γ0, KT), ψ0, tlist, nothing, e_ops = e_ops)\n\n    push!(results, (γ0 = γ0, expect = result.expect))\nend\n\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\nThe expectation values dynamics of \\(\\hat{\\sigma}^{+}\\) and \\(\\hat{\\sigma}^{-}\\) shows the driving-field-induced dipole moment of the atom oscillates and persists.\n\nfig2 = Figure(size = (600,300))\nax2 = Axis(\n    fig2[1,1],\n    xlabel = L\"time $[1/\\Omega]$\",\n    title = L\"\\langle\\hat{\\sigma}_{+}\\rangle\"\n)\n\nfor (γ0, expect) in results\n    lines!(ax2, tlist, imag(expect[5,:]), label = \"γ0 = $γ0\")\nend\n\naxislegend(ax2)\ndisplay(fig2);\n\n\n\n\n\n\n\n\n\nfig3 = Figure(size = (600,300))\nax3 = Axis(\n    fig3[1,1],\n    xlabel = L\"time $[1/\\Omega]$\",\n    title = L\"\\langle\\hat{\\sigma}_{-}\\rangle\"\n)\n\nfor (γ0, expect) in results\n    lines!(ax3, tlist, imag(expect[4,:]), label = \"γ0 = $γ0\")\nend\naxislegend(ax3)\ndisplay(fig3);\n\n\n\n\n\n\n\n\nWe now move to the analysis of the correlation function \\(C(\\tau) = \\langle \\hat{\\sigma}^{+}(\\tau) \\hat{\\sigma}^{-}(0)\\rangle\\), which describes the radiative behaviour of the atom towards its surrounding environment. Using correlation_2op_1t, we can obtain the correlation function as a function of \\(\\tau\\) and use spectrum_correlation_fft to obtain the corresponding Fourier transform.\n\nfig4 = Figure(size = (600,300))\nax41 = Axis(\n    fig4[1,1],\n    xlabel = L\"\\tau\",\n    title = L\"C(\\tau)\"\n)\n\nax42 = Axis(\n    fig4[1,2],\n    xlabel = L\"\\omega\",\n    ylabel = \"fft amplitude\"\n)\nτlist = 0:0.1:100\nfor γ0 in γ0s\n    L = liouvillian_spec(Ω, γ0, KT)    \n    corr = correlation_2op_1t(L, ψ0, τlist, nothing, sigmap(), sigmam())\n\n    lines!(ax41, τlist, real(corr), label = \"γ0 = $γ0\")\n\n    fft_ωlist, fft_spect = spectrum_correlation_fft(τlist, corr)\n    lines!(ax42, fft_ωlist, fft_spect, label = \"γ0 = $γ0\")\nend\nxlims!(ax42, (-2,2))\naxislegend(ax41)\naxislegend(ax42)\ndisplay(fig4);\n\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\n\n\n\n\n\n\n\nIn the above plots, one finds that the correlation functions decay faster with higher dissipation rate, and therefore the lower spectral peaks. On the other hand, the higher spectral peaks means the radiation is brighter in terms of intensity."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/fluorescence.html#version-information",
    "href": "QuantumToolbox.jl/time_evolution/fluorescence.html#version-information",
    "title": "Resonance fluorescence",
    "section": "Version Information",
    "text": "Version Information\n\nimport QuantumToolbox\nQuantumToolbox.versioninfo()\n\n\n QuantumToolbox.jl: Quantum Toolbox in Julia\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2022 and later.\nCurrent admin team:\n    Alberto Mercurio and Yi-Te Huang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html",
    "title": "Driven systems and dynamical decoupling",
    "section": "",
    "text": "Inspirations taken from an example in QuTiP-BoFiN article (Lambert et al. 2023)."
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#introduction",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#introduction",
    "title": "Driven systems and dynamical decoupling",
    "section": "Introduction",
    "text": "Introduction\nIn this example, we show how to solve the time evolution with time-dependent Hamiltonian problems in hierarchical equations of motion approach.\nHere, we study dynamical decoupling which is a common tool used to undo the dephasing effect from the environment even for finite pulse duration."
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#hamiltonian",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#hamiltonian",
    "title": "Driven systems and dynamical decoupling",
    "section": "Hamiltonian",
    "text": "Hamiltonian\nWe consider a two-level system coupled to a bosonic reservoir (\\(\\textrm{b}\\)). The total Hamiltonian is given by \\(H_{\\textrm{T}}=H_\\textrm{s}+H_\\textrm{b}+H_\\textrm{sb}\\), where each terms takes the form\n\\[\n\\begin{aligned}\nH_{\\textrm{s}}(t) &= H_0 + H_{\\textrm{D}}(t),\\\\\nH_0               &= \\frac{\\omega_0}{2} \\sigma_z,\\\\\nH_{\\textrm{b}}    &=\\sum_{k}\\omega_{k}b_{k}^{\\dagger}b_{k},\\\\\nH_{\\textrm{sb}}   &=\\sigma_z\\sum_{k}g_{\\alpha,k}(b_k + b_k^{\\dagger}).\n\\end{aligned}\n\\]\nHere, \\(H_{\\textrm{b}}\\) describes a bosonic reservoir where \\(b_{k}\\) \\((b_{k}^{\\dagger})\\) is the bosonic annihilation (creation) operator associated to the \\(k\\)th mode (with frequency \\(\\omega_{k}\\)).\nFurthermore, to observe the time evolution of the coherence, we consider the initial state to be \\[\nψ(t=0)=\\frac{1}{\\sqrt{2}}\\left(|0\\rangle+|1\\rangle\\right)\n\\]\nNow, we need to build the system Hamiltonian and initial state with the package QuantumToolbox.jl to construct the operators.\n\nusing HierarchicalEOM  # this automatically loads `QuantumToolbox`\nusing CairoMakie       # for plotting results\n\n\nω0 = 0.0\nσz = sigmaz()\nσx = sigmax()\nH0 = 0.5 * ω0 * σz\n\n# Define the operator that measures the 0, 1 element of density matrix\nρ01 = Qobj([0 1; 0 0])\n\nψ0 = (basis(2, 0) + basis(2, 1)) / √2\n\n\nQuantum Object:   type=Ket   dims=[2]   size=(2,)\n2-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\n\nThe time-dependent driving term \\(H_{\\textrm{D}}(t)\\) has the form\n\\[\nH_{\\textrm{D}}(t) = \\sum_{n=1}^N f_n(t) \\sigma_x\n\\]\nwhere the pulse is chosen to have duration \\(\\tau\\) together with a delay \\(\\Delta\\) between each pulses, namely\n\\[\nf_n(t)\n= \\begin{cases}\n  V & \\textrm{if}~~(n-1)\\tau + n\\Delta \\leq t \\leq n (\\tau + \\Delta),\\\\\n  0 & \\textrm{otherwise}.\n  \\end{cases}\n\\]\nHere, we set the period of the pulses to be \\(\\tau V = \\pi/2\\). Therefore, we consider two scenarios with fast and slow pulses:\n\n# a function which returns the amplitude of the pulse at time t\nfunction pulse(p, t)\n    τ = 0.5 * π / p.V\n    period = τ + p.Δ\n\n    if (t % period) &lt; τ\n        return p.V\n    else\n        return 0\n    end\nend\n\ntlist = 0:0.4:400\namp_fast = 0.50\namp_slow = 0.01\ndelay = 20\n\nfastTuple = (V = amp_fast, Δ = delay)\nslowTuple = (V = amp_slow, Δ = delay)\n\n# plot\nfig = Figure(size = (600, 350))\nax = Axis(fig[1, 1], xlabel = L\"t\")\nlines!(ax, tlist, [pulse(fastTuple, t) for t in tlist], label = \"Fast Pulse\", linestyle = :solid)\nlines!(ax, tlist, [pulse(slowTuple, t) for t in tlist], label = \"Slow Pulse\", linestyle = :dash)\n\naxislegend(ax, position = :rt)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#construct-bath-objects",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#construct-bath-objects",
    "title": "Driven systems and dynamical decoupling",
    "section": "Construct bath objects",
    "text": "Construct bath objects\nWe assume the bosonic reservoir to have a Drude-Lorentz Spectral Density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:\n\nthe coupling strength \\(\\Gamma\\) between system and reservoir\nthe band-width \\(W\\)\nthe product of the Boltzmann constant \\(k\\) and the absolute temperature \\(T\\) : \\(kT\\)\nthe total number of exponentials for the reservoir \\((N + 1)\\)\n\n\nΓ = 0.0005\nW = 0.005\nkT = 0.05\nN = 3\nbath = Boson_DrudeLorentz_Pade(σz, Γ, W, kT, N)\n\nHierarchicalEOM.BosonBath object with 4 terms."
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#construct-heomls-matrix",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#construct-heomls-matrix",
    "title": "Driven systems and dynamical decoupling",
    "section": "Construct HEOMLS matrix",
    "text": "Construct HEOMLS matrix\n\n\n\n\n\n\nWarning\n\n\n\nOnly provide the time-independent part of system Hamiltonian when constructing HEOMLS matrices (the time-dependent part H_t should be given when solving the time evolution).\n\n\n\ntier = 6\nM = M_Boson(H0, tier, bath)\n\nPreparing block matrices for HEOM Liouvillian superoperator (using 4 threads)...\nProgress: [                              ]   1.4% --- Elapsed Time: 0h 00m 01s (ETA: 0h 01m 09s)Progress: [                              ]   1.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 01m 44s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 00s)\nConstructing matrix...[DONE]\n\n\nBoson type HEOMLS matrix acting on even-parity ADOs\nsystem dims = [2]\nnumber of ADOs N = 210\ndata =\nMatrixOperator(840 × 840)"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#time-evolution-with-time-independent-hamiltonian",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#time-evolution-with-time-independent-hamiltonian",
    "title": "Driven systems and dynamical decoupling",
    "section": "time evolution with time-independent Hamiltonian",
    "text": "time evolution with time-independent Hamiltonian\n\nnoPulseSol = HEOMsolve(M, ψ0, tlist; e_ops = [ρ01]);\n\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [                              ]   0.1% --- Elapsed Time: 0h 00m 02s (ETA: 0h 33m 20s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 00s)"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#solve-time-evolution-with-time-dependent-hamiltonian",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#solve-time-evolution-with-time-dependent-hamiltonian",
    "title": "Driven systems and dynamical decoupling",
    "section": "Solve time evolution with time-dependent Hamiltonian",
    "text": "Solve time evolution with time-dependent Hamiltonian\nWe need to provide a QuantumToolbox.QuantumObjectEvolution (named as H_D in this case)\n\nH_D = QobjEvo(σx, pulse)\n\n\nQuantum Object Evo.:   type=Operator   dims=[2]   size=(2, 2)   ishermitian=true   isconstant=false\nScalarOperator(0.0 + 0.0im) * MatrixOperator(2 × 2)\n\n\nThe keyword argument params in HEOMsolve will be passed to the argument p in user-defined function (pulse in this case) directly:\n\nfastPulseSol = HEOMsolve(M, ψ0, tlist; e_ops = [ρ01], H_t = H_D, params = fastTuple)\nslowPulseSol = HEOMsolve(M, ψ0, tlist; e_ops = [ρ01], H_t = H_D, params = slowTuple)\n\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [                              ]   0.1% --- Elapsed Time: 0h 00m 02s (ETA: 0h 33m 20s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 00s)\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\nSolution of hierarchical EOM\n(return code: Success)\n----------------------------\nBtier = 6\nFtier = 0\nnum_ados   = 1\nnum_expect = 1\nODE alg.: OrdinaryDiffEqLowOrderRK.DP5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false))\nabstol = 1.0e-8\nreltol = 1.0e-6"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#plot-the-coherence",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#plot-the-coherence",
    "title": "Driven systems and dynamical decoupling",
    "section": "Plot the coherence",
    "text": "Plot the coherence\n\nfig = Figure(size = (600, 350))\nax = Axis(fig[1, 1], xlabel = L\"t\", ylabel = L\"\\rho_{01}\")\nlines!(ax, tlist, real(fastPulseSol.expect[1, :]), label = \"Fast Pulse\", linestyle = :solid)\nlines!(ax, tlist, real(slowPulseSol.expect[1, :]), label = \"Slow Pulse\", linestyle = :dot)\nlines!(ax, tlist, real(noPulseSol.expect[1, :]),   label = \"no Pulse\",   linestyle = :dash)\n\naxislegend(ax, position = :lb)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/dynamical_decoupling.html#version-information",
    "href": "HierarchicalEOM.jl/dynamical_decoupling.html#version-information",
    "title": "Driven systems and dynamical decoupling",
    "section": "Version Information",
    "text": "Version Information\n\nHierarchicalEOM.versioninfo()\n\n\n                                   __\n                                  /  \\\n __     __                     __ \\__/ __\n|  |   |  |                   /  \\    /  \\\n|  |   |  | ______   ______   \\__/_  _\\__/\n|  |___|  |/  __  \\ /  __  \\ / '   \\/     \\\n|   ___   |  |__)  |  /  \\  |    _     _   |\n|  |   |  |   ____/| (    ) |   / \\   / \\  |\n|  |   |  |  |____ |  \\__/  |  |   | |   | |\n|__|   |__|\\______) \\______/|__|   |_|   |_|\n\nJulia framework for Hierarchical Equations of Motion\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2023 and later.\nLead  developer : Yi-Te Huang\nOther developers:\n    Simon Cross, Neill Lambert, Po-Chen Kuo and Shen-Liang Yang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nHierarchicalEOM    Ver. 2.4.2\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html",
    "href": "HierarchicalEOM.jl/SIAM.html",
    "title": "Single-impurity Anderson model",
    "section": "",
    "text": "The investigation of the Kondo effect in single-impurity Anderson model is crucial as it serves both as a valuable testing ground for the theories of the Kondo effect and has the potential to lead to a better understanding of this intrinsic many-body phenomena. For further detailed discussions of this model (under different parameters) using HierarchicalEOM.jl, we recommend to read the article (Huang et al. 2023)."
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#introduction",
    "href": "HierarchicalEOM.jl/SIAM.html#introduction",
    "title": "Single-impurity Anderson model",
    "section": "",
    "text": "The investigation of the Kondo effect in single-impurity Anderson model is crucial as it serves both as a valuable testing ground for the theories of the Kondo effect and has the potential to lead to a better understanding of this intrinsic many-body phenomena. For further detailed discussions of this model (under different parameters) using HierarchicalEOM.jl, we recommend to read the article (Huang et al. 2023)."
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#hamiltonian",
    "href": "HierarchicalEOM.jl/SIAM.html#hamiltonian",
    "title": "Single-impurity Anderson model",
    "section": "Hamiltonian",
    "text": "Hamiltonian\nWe consider a single-level electronic system [which can be populated by a spin-up (\\(\\uparrow\\)) or spin-down (\\(\\downarrow\\)) electron] coupled to a fermionic reservoir (\\(\\textrm{f}\\)). The total Hamiltonian is given by \\(H_{\\textrm{T}}=H_\\textrm{s}+H_\\textrm{f}+H_\\textrm{sf}\\), where each terms takes the form\n\\[\n\\begin{aligned}\nH_{\\textrm{s}}  &= \\epsilon \\left(d^\\dagger_\\uparrow d_\\uparrow + d^\\dagger_\\downarrow d_\\downarrow \\right) + U\\left(d^\\dagger_\\uparrow d_\\uparrow d^\\dagger_\\downarrow d_\\downarrow\\right),\\\\\nH_{\\textrm{f}}  &=\\sum_{\\sigma=\\uparrow,\\downarrow}\\sum_{k}\\epsilon_{\\sigma,k}c_{\\sigma,k}^{\\dagger}c_{\\sigma,k},\\\\\nH_{\\textrm{sf}} &=\\sum_{\\sigma=\\uparrow,\\downarrow}\\sum_{k}g_{k}c_{\\sigma,k}^{\\dagger}d_{\\sigma} + g_{k}^*d_{\\sigma}^{\\dagger}c_{\\sigma,k}.\n\\end{aligned}\n\\]\nHere, \\(d_\\uparrow\\) \\((d_\\downarrow)\\) annihilates a spin-up (spin-down) electron in the system, \\(\\epsilon\\) is the energy of the electron, and \\(U\\) is the Coulomb repulsion energy for double occupation. Furthermore, \\(c_{\\sigma,k}\\) \\((c_{\\sigma,k}^{\\dagger})\\) annihilates (creates) an electron in the state \\(k\\) (with energy \\(\\epsilon_{\\sigma,k}\\)) of the reservoir.\nNow, we need to build the system Hamiltonian and initial state with the package QuantumToolbox.jl to construct the operators.\n\nusing HierarchicalEOM  # this automatically loads `QuantumToolbox`\nusing CairoMakie       # for plotting results\n\n\nϵ = -5\nU = 10\nσm = sigmam() # σ-\nσz = sigmaz() # σz\nII = qeye(2)  # identity matrix\n\n# construct the annihilation operator for both spin-up and spin-down\n# (utilize Jordan–Wigner transformation)\nd_up = tensor(σm, II)\nd_dn = tensor(-1 * σz, σm)\nHsys = ϵ * (d_up' * d_up + d_dn' * d_dn) + U * (d_up' * d_up * d_dn' * d_dn)\n\n\nQuantum Object:   type=Operator   dims=[2, 2]   size=(4, 4)   ishermitian=true\n4×4 SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅           ⋅           ⋅          ⋅    \n     ⋅      -5.0+0.0im       ⋅          ⋅    \n     ⋅           ⋅      -5.0+0.0im      ⋅    \n     ⋅           ⋅           ⋅          ⋅"
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#construct-bath-objects",
    "href": "HierarchicalEOM.jl/SIAM.html#construct-bath-objects",
    "title": "Single-impurity Anderson model",
    "section": "Construct bath objects",
    "text": "Construct bath objects\nWe assume the fermionic reservoir to have a Lorentzian-shaped spectral density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:\n\nthe coupling strength \\(\\Gamma\\) between system and reservoirs\nthe band-width \\(W\\)\nthe product of the Boltzmann constant \\(k\\) and the absolute temperature \\(T\\) : \\(kT\\)\nthe chemical potential \\(\\mu\\)\nthe total number of exponentials for the reservoir \\(2(N + 1)\\)\n\n\nΓ = 2\nμ = 0\nW = 10\nkT = 0.5\nN = 5\nbath_up = Fermion_Lorentz_Pade(d_up, Γ, μ, W, kT, N)\nbath_dn = Fermion_Lorentz_Pade(d_dn, Γ, μ, W, kT, N)\nbath_list = [bath_up, bath_dn]\n\n2-element Vector{FermionBath}:\n HierarchicalEOM.FermionBath object with 12 terms.\n\n HierarchicalEOM.FermionBath object with 12 terms."
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#construct-heomls-matrix",
    "href": "HierarchicalEOM.jl/SIAM.html#construct-heomls-matrix",
    "title": "Single-impurity Anderson model",
    "section": "Construct HEOMLS matrix",
    "text": "Construct HEOMLS matrix\n\ntier = 3\nM_even = M_Fermion(Hsys, tier, bath_list)\nM_odd = M_Fermion(Hsys, tier, bath_list, ODD)\n\nPreparing block matrices for HEOM Liouvillian superoperator (using 4 threads)...\nProgress: [                              ]   0.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 38m 44s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 00s)\nConstructing matrix...[DONE]\nPreparing block matrices for HEOM Liouvillian superoperator (using 4 threads)...\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nConstructing matrix...[DONE]\n\n\nFermion type HEOMLS matrix acting on odd-parity ADOs\nsystem dims = [2, 2]\nnumber of ADOs N = 2325\ndata =\nMatrixOperator(37200 × 37200)"
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#solve-stationary-state-of-ados",
    "href": "HierarchicalEOM.jl/SIAM.html#solve-stationary-state-of-ados",
    "title": "Single-impurity Anderson model",
    "section": "Solve stationary state of ADOs",
    "text": "Solve stationary state of ADOs\n\nados_s = steadystate(M_even)\n\nSolving steady state for ADOs by linear-solve method...[DONE]\n\n\n2325 Auxiliary Density Operators with even-parity and (system) dims = [2, 2]"
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#calculate-density-of-states-dos",
    "href": "HierarchicalEOM.jl/SIAM.html#calculate-density-of-states-dos",
    "title": "Single-impurity Anderson model",
    "section": "Calculate density of states (DOS)",
    "text": "Calculate density of states (DOS)\n\nωlist = -10:1:10\ndos = DensityOfStates(M_odd, ados_s, d_up, ωlist)\n\nCalculating density of states in frequency domain...\nProgress: [=====                         ]  19.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 04s)Progress: [============                  ]  42.9% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 02s)Progress: [====================          ]  66.7% --- Elapsed Time: 0h 00m 03s (ETA: 0h 00m 01s)Progress: [============================  ]  95.2% --- Elapsed Time: 0h 00m 04s (ETA: 0h 00m 00s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 04s (ETA: 0h 00m 00s)\n[DONE]\n\n\n21-element Vector{Float64}:\n 0.024341620652868125\n 0.04465552042384671\n 0.09077144051561165\n 0.1929888055674428\n 0.29351536894471525\n 0.23367107985909338\n 0.15864674406917825\n 0.1237987795050877\n 0.11772111509217494\n 0.14524303704733388\n ⋮\n 0.11772111509217663\n 0.12379877950508988\n 0.15864674406918147\n 0.2336710798590986\n 0.2935153689447211\n 0.1929888055674464\n 0.090771440515613\n 0.044655520423847135\n 0.024341620652868233\n\n\nplot the results\n\nfig = Figure(size = (500, 350))\nax = Axis(fig[1, 1], xlabel = L\"\\omega\")\nlines!(ax, ωlist, dos)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/SIAM.html#version-information",
    "href": "HierarchicalEOM.jl/SIAM.html#version-information",
    "title": "Single-impurity Anderson model",
    "section": "Version Information",
    "text": "Version Information\n\nHierarchicalEOM.versioninfo()\n\n\n                                   __\n                                  /  \\\n __     __                     __ \\__/ __\n|  |   |  |                   /  \\    /  \\\n|  |   |  | ______   ______   \\__/_  _\\__/\n|  |___|  |/  __  \\ /  __  \\ / '   \\/     \\\n|   ___   |  |__)  |  /  \\  |    _     _   |\n|  |   |  |   ____/| (    ) |   / \\   / \\  |\n|  |   |  |  |____ |  \\__/  |  |   | |   | |\n|__|   |__|\\______) \\______/|__|   |_|   |_|\n\nJulia framework for Hierarchical Equations of Motion\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2023 and later.\nLead  developer : Yi-Te Huang\nOther developers:\n    Simon Cross, Neill Lambert, Po-Chen Kuo and Shen-Liang Yang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nHierarchicalEOM    Ver. 2.4.2\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "QuantumToolbox.jl/toc.html",
    "href": "QuantumToolbox.jl/toc.html",
    "title": "Tutorials for QuantumToolbox.jl",
    "section": "",
    "text": "The following tutorials demonstrate and introduce specific functionality of QuantumToolbox.jl.\n\nTime Evolution\n\n\n\n\n\nLast Update\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\n2025-01-27\n\n\nResonance fluorescence\n\n\nLi-Xun Cai\n\n\n\n\n2025-01-20\n\n\nLow rank master equation\n\n\nLuca Gravina\n\n\n\n\n2025-01-17\n\n\nVacuum Rabi oscillation\n\n\nLi-Xun Cai\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "HierarchicalEOM.jl/toc.html",
    "href": "HierarchicalEOM.jl/toc.html",
    "title": "Tutorials for HierarchicalEOM.jl",
    "section": "",
    "text": "The following tutorials demonstrate and introduce specific functionality of HierarchicalEOM.jl.\n\nExamples\n\n\n\n\n\nLast Update\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\n2025-01-14\n\n\nSingle-impurity Anderson model\n\n\nYi-Te Huang\n\n\n\n\n2025-01-13\n\n\nCavity QED system\n\n\nShen-Liang Yang, Yi-Te Huang\n\n\n\n\n2025-01-14\n\n\nDriven systems and dynamical decoupling\n\n\nYi-Te Huang\n\n\n\n\n2025-01-14\n\n\nElectronic Current\n\n\nYi-Te Huang\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorials for Quantum Toolbox in Julia",
    "section": "",
    "text": "This website contains our collection of tutorials for introducing and demonstrating features of Quantum Toolbox in Julia. Going through these tutorials should be a good way to get familiarized with the software. If you are new to scientific computing with Julia, you might also find it useful to have a look at the Julia tutorials website.\nYou can find the tutorials of our packages from the navbar on top, or the following links:\n\n\n\nPackage\nTutorials\nGitHub Repository\nDocumentation\n\n\n\n\nQuantumToolbox.jl\nlink\nlink\nlink\n\n\nHierarchicalEOM.jl\nlink\nlink\nlink"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html",
    "href": "HierarchicalEOM.jl/cavityQED.html",
    "title": "Cavity QED system",
    "section": "",
    "text": "Cavity quantum electrodynamics (cavity QED) is an important topic for studying the interaction between atoms (or other particles) and light confined in a reflective cavity, under conditions where the quantum nature of photons is significant."
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#introduction",
    "href": "HierarchicalEOM.jl/cavityQED.html#introduction",
    "title": "Cavity QED system",
    "section": "",
    "text": "Cavity quantum electrodynamics (cavity QED) is an important topic for studying the interaction between atoms (or other particles) and light confined in a reflective cavity, under conditions where the quantum nature of photons is significant."
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#hamiltonian",
    "href": "HierarchicalEOM.jl/cavityQED.html#hamiltonian",
    "title": "Cavity QED system",
    "section": "Hamiltonian",
    "text": "Hamiltonian\nThe Jaynes-Cummings model is a standard model in the realm of cavity QED. It illustrates the interaction between a two-level atom (\\(\\textrm{A}\\)) and a quantized single-mode within a cavity (\\(\\textrm{c}\\)).\nNow, we need to build the system Hamiltonian and initial state with the package QuantumToolbox.jl to construct the operators.\n\\[\n\\begin{aligned}\nH_{\\textrm{s}}&=H_{\\textrm{A}}+H_{\\textrm{c}}+H_{\\textrm{int}},\\\\\nH_{\\textrm{A}}&=\\frac{\\omega_A}{2}\\sigma_z,\\\\\nH_{\\textrm{c}}&=\\omega_{\\textrm{c}} a^\\dagger a,\\\\\nH_{\\textrm{int}}&=g (a^\\dagger\\sigma^-+a\\sigma^+),\n\\end{aligned}\n\\]\nwhere \\(\\sigma^-\\) (\\(\\sigma^+\\)) is the annihilation (creation) operator of the atom, and \\(a\\) (\\(a^\\dagger\\)) is the annihilation (creation) operator of the cavity.\nFurthermore, we consider the system is coupled to a bosonic reservoir (\\(\\textrm{b}\\)). The total Hamiltonian is given by \\(H_{\\textrm{Total}}=H_\\textrm{s}+H_\\textrm{b}+H_\\textrm{sb}\\), where \\(H_\\textrm{b}\\) and \\(H_\\textrm{sb}\\) takes the form\n\\[\n\\begin{aligned}\nH_{\\textrm{b}}    &=\\sum_{k}\\omega_{k}b_{k}^{\\dagger}b_{k},\\\\\nH_{\\textrm{sb}}   &=(a+a^\\dagger)\\sum_{k}g_{k}(b_k + b_k^{\\dagger}).\n\\end{aligned}\n\\]\nHere, \\(H_{\\textrm{b}}\\) describes a bosonic reservoir where \\(b_{k}\\) \\((b_{k}^{\\dagger})\\) is the bosonic annihilation (creation) operator associated to the \\(k\\)th mode (with frequency \\(\\omega_{k}\\)). Also, \\(H_{\\textrm{sb}}\\) illustrates the interaction between the cavity and the bosonic reservoir.\nNow, we need to build the system Hamiltonian and initial state with the package QuantumToolbox.jl to construct the operators.\n\nusing HierarchicalEOM  # this automatically loads `QuantumToolbox`\nusing CairoMakie       # for plotting results\n\n\nN = 3 # system cavity Hilbert space cutoff\nωA = 2\nωc = 2\ng = 0.1\n\n# operators\na_c = destroy(N)\nI_c = qeye(N)\nσz_A = sigmaz()\nσm_A = sigmam()\nI_A = qeye(2)\n\n# operators in tensor-space\na = tensor(a_c, I_A)\nσz = tensor(I_c, σz_A)\nσm = tensor(I_c, σm_A)\n\n# Hamiltonian\nH_A = 0.5 * ωA * σz\nH_c = ωc * a' * a\nH_int = g * (a' * σm + a * σm')\nH_s = H_A + H_c + H_int\n\n# initial state\nψ0 = tensor(basis(N, 0), basis(2, 0));"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#construct-bath-objects",
    "href": "HierarchicalEOM.jl/cavityQED.html#construct-bath-objects",
    "title": "Cavity QED system",
    "section": "Construct bath objects",
    "text": "Construct bath objects\nWe assume the bosonic reservoir to have a Drude-Lorentz Spectral Density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:\n\nthe coupling strength \\(\\Gamma\\) between system and reservoir\nthe band-width \\(W\\)\nthe product of the Boltzmann constant \\(k\\) and the absolute temperature \\(T\\) : \\(kT\\)\nthe total number of exponentials for the reservoir \\((N + 1)\\)\n\n\nΓ = 0.01\nW = 1\nkT = 0.025\nN = 20\nBath = Boson_DrudeLorentz_Pade(a + a', Γ, W, kT, N)\n\nHierarchicalEOM.BosonBath object with 21 terms.\n\n\nBefore incorporating the correlation function into the HEOMLS matrix, it is essential to verify (by using correlation_function) if the total number of exponentials for the reservoir sufficiently describes the practical situation.\n\ntlist_test = 0:0.1:10;\nBath_test = Boson_DrudeLorentz_Pade(a + a', Γ, W, kT, 1000);\nCt = correlation_function(Bath, tlist_test);\nCt2 = correlation_function(Bath_test, tlist_test)\n\n# plot\nfig = Figure(size = (500, 350))\nax = Axis(fig[1, 1], xlabel = L\"t\", ylabel = L\"C(t)\")\nlines!(ax, tlist_test, real(Ct2), label = L\"$N=1000$ (real part)\", linestyle = :solid)\nlines!(ax, tlist_test, real(Ct),  label = L\"$N=20$ (real part)\", linestyle = :dash)\nlines!(ax, tlist_test, imag(Ct2), label = L\"$N=1000$ (imag part)\", linestyle = :solid)\nlines!(ax, tlist_test, imag(Ct),  label = L\"$N=20$ (imag part)\", linestyle = :dash)\n\naxislegend(ax, position = :rt)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#construct-heomls-matrix",
    "href": "HierarchicalEOM.jl/cavityQED.html#construct-heomls-matrix",
    "title": "Cavity QED system",
    "section": "Construct HEOMLS matrix",
    "text": "Construct HEOMLS matrix\nHere, we consider an incoherent pumping to the atom, which can be described by an Lindblad dissipator (see here for more details).\nFurthermore, we set the important threshold to be 1e-6.\n\npump = 0.01\nJ_pump = sqrt(pump) * σm'\ntier = 2\nM_Heom = M_Boson(H_s, tier, threshold = 1e-6, Bath)\nM_Heom = addBosonDissipator(M_Heom, J_pump)\n\nChecking the importance value for each ADOs...[DONE]\nPreparing block matrices for HEOM Liouvillian superoperator (using 4 threads)...\nProgress: [=============                 ]  46.4% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 01s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 00s)\nConstructing matrix...[DONE]\n\n\nBoson type HEOMLS matrix acting on even-parity ADOs\nsystem dims = [3, 2]\nnumber of ADOs N = 97\ndata =\nMatrixOperator(3492 × 3492)"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#solve-time-evolution-of-ados",
    "href": "HierarchicalEOM.jl/cavityQED.html#solve-time-evolution-of-ados",
    "title": "Cavity QED system",
    "section": "Solve time evolution of ADOs",
    "text": "Solve time evolution of ADOs\n\nt_list = 0:1:500\nsol_H = HEOMsolve(M_Heom, ψ0, t_list; e_ops = [σz, a' * a])\n\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [                              ]   0.2% --- Elapsed Time: 0h 00m 02s (ETA: 0h 16m 40s)Progress: [====================          ]  67.3% --- Elapsed Time: 0h 00m 03s (ETA: 0h 00m 01s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 04s (ETA: 0h 00m 00s)\n\n\nSolution of hierarchical EOM\n(return code: Success)\n----------------------------\nBtier = 2\nFtier = 0\nnum_ados   = 1\nnum_expect = 2\nODE alg.: OrdinaryDiffEqLowOrderRK.DP5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false))\nabstol = 1.0e-8\nreltol = 1.0e-6"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#solve-stationary-state-of-ados",
    "href": "HierarchicalEOM.jl/cavityQED.html#solve-stationary-state-of-ados",
    "title": "Cavity QED system",
    "section": "Solve stationary state of ADOs",
    "text": "Solve stationary state of ADOs\n\nsteady_H = steadystate(M_Heom);\n\nSolving steady state for ADOs by linear-solve method...[DONE]"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#expectation-values",
    "href": "HierarchicalEOM.jl/cavityQED.html#expectation-values",
    "title": "Cavity QED system",
    "section": "Expectation values",
    "text": "Expectation values\nobservable of atom: \\(\\sigma_z\\)\n\nσz_evo_H = real(sol_H.expect[1, :])\nσz_steady_H = expect(σz, steady_H)\n\n-0.3731173931282959\n\n\nobservable of cavity: \\(a^\\dagger a\\) (average photon number)\n\nnp_evo_H = real(sol_H.expect[2, :])\nnp_steady_H = expect(a' * a, steady_H)\n\n0.4312130158260074\n\n\nplot results\n\nfig = Figure(size = (600, 350))\n\nax1 = Axis(fig[1, 1], xlabel = L\"t\")\nlines!(ax1, t_list, σz_evo_H, label = L\"\\langle \\sigma_z \\rangle\", linestyle = :solid)\nlines!(ax1, t_list, ones(length(t_list)) .* σz_steady_H, label = L\"\\langle \\sigma_z \\rangle ~~(\\textrm{steady})\", linestyle = :dash)\naxislegend(ax1, position = :rt)\n\nax2 = Axis(fig[2, 1], xlabel = L\"t\")\nlines!(ax2, t_list, np_evo_H, label = L\"\\langle a^\\dagger a \\rangle\", linestyle = :solid)\nlines!(ax2, t_list, ones(length(t_list)) .* np_steady_H, label = L\"\\langle a^\\dagger a \\rangle ~~(\\textrm{steady})\", linestyle = :dash)\naxislegend(ax2, position = :rt)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#power-spectrum",
    "href": "HierarchicalEOM.jl/cavityQED.html#power-spectrum",
    "title": "Cavity QED system",
    "section": "Power spectrum",
    "text": "Power spectrum\n\nω_list = 1:0.01:3\npsd_H = PowerSpectrum(M_Heom, steady_H, a, ω_list)\n\n# plot\nfig = Figure(size = (500, 350))\nax = Axis(fig[1, 1], xlabel = L\"\\omega\")\nlines!(ax, ω_list, psd_H)\n\nfig\n\nCalculating power spectrum in frequency domain...\nProgress: [========                      ]  29.9% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 02s)Progress: [==================            ]  60.7% --- Elapsed Time: 0h 00m 02s (ETA: 0h 00m 01s)Progress: [===========================   ]  92.0% --- Elapsed Time: 0h 00m 03s (ETA: 0h 00m 00s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 03s (ETA: 0h 00m 00s)\n[DONE]"
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#compare-with-master-eq.-approach",
    "href": "HierarchicalEOM.jl/cavityQED.html#compare-with-master-eq.-approach",
    "title": "Cavity QED system",
    "section": "Compare with Master Eq. approach",
    "text": "Compare with Master Eq. approach\nThe Lindblad master equations which describes the cavity couples to an extra bosonic reservoir with Drude-Lorentzian spectral density is given by\n\n# Drude_Lorentzian spectral density\nDrude_Lorentz(ω, Γ, W) = 4 * Γ * W * ω / ((ω)^2 + (W)^2)\n\n# Bose-Einstein distribution\nn_b(ω, kT) = 1 / (exp(ω / kT) - 1)\n\n# build the jump operators\njump_op = [\n    sqrt(Drude_Lorentz(ωc, Γ, W) * (n_b(ωc, kT) + 1)) * a,\n    sqrt(Drude_Lorentz(ωc, Γ, W) * (n_b(ωc, kT)))     * a',\n    J_pump\n];\n\n# construct the HEOMLS matrix for master equation\nM_master = M_S(H_s)\nM_master = addBosonDissipator(M_master, jump_op)\n\n# time evolution\nsol_M = HEOMsolve(M_master, ψ0, t_list; e_ops = [σz, a' * a]);\n\n# steady state\nsteady_M = steadystate(M_master);\n\n# expectation value of σz\nσz_evo_M = real(sol_M.expect[1, :])\nσz_steady_M = expect(σz, steady_M)\n\n# average photon number\nnp_evo_M = real(sol_M.expect[2, :])\nnp_steady_M = expect(a' * a, steady_M);\n\nConstructing Liouville-von Neumann superoperator...\n[DONE]\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\nSolving steady state for ADOs by linear-solve method...[DONE]\n\n\nplot results\n\nfig = Figure(size = (600, 350))\n\nax1 = Axis(fig[1, 1], xlabel = L\"t\")\nlines!(ax1, t_list, σz_evo_M, label = L\"\\langle \\sigma_z \\rangle\", linestyle = :solid)\nlines!(ax1, t_list, ones(length(t_list)) .* σz_steady_M, label = L\"\\langle \\sigma_z \\rangle ~~(\\textrm{steady})\", linestyle = :dash)\naxislegend(ax1, position = :rt)\n\nax2 = Axis(fig[2, 1], xlabel = L\"t\")\nlines!(ax2, t_list, np_evo_M, label = L\"\\langle a^\\dagger a \\rangle\", linestyle = :solid)\nlines!(ax2, t_list, ones(length(t_list)) .* np_steady_M, label = L\"\\langle a^\\dagger a \\rangle ~~(\\textrm{steady})\", linestyle = :dash)\naxislegend(ax2, position = :rt)\n\nfig\n\n\n\n\n\n\n\n\nWe can also calculate the power spectrum\n\nω_list = 1:0.01:3\npsd_M = PowerSpectrum(M_master, steady_M, a, ω_list)\n\n# plot\nfig = Figure(size = (500, 350))\nax = Axis(fig[1, 1], xlabel = L\"\\omega\")\nlines!(ax, ω_list, psd_M)\n\nfig\n\nCalculating power spectrum in frequency domain...\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n[DONE]\n\n\n\n\n\n\n\n\n\nDue to the weak coupling between the system and an extra bosonic environment, the Master equation’s outcome is expected to be similar to the results obtained from the HEOM method."
  },
  {
    "objectID": "HierarchicalEOM.jl/cavityQED.html#version-information",
    "href": "HierarchicalEOM.jl/cavityQED.html#version-information",
    "title": "Cavity QED system",
    "section": "Version Information",
    "text": "Version Information\n\nHierarchicalEOM.versioninfo()\n\n\n                                   __\n                                  /  \\\n __     __                     __ \\__/ __\n|  |   |  |                   /  \\    /  \\\n|  |   |  | ______   ______   \\__/_  _\\__/\n|  |___|  |/  __  \\ /  __  \\ / '   \\/     \\\n|   ___   |  |__)  |  /  \\  |    _     _   |\n|  |   |  |   ____/| (    ) |   / \\   / \\  |\n|  |   |  |  |____ |  \\__/  |  |   | |   | |\n|__|   |__|\\______) \\______/|__|   |_|   |_|\n\nJulia framework for Hierarchical Equations of Motion\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2023 and later.\nLead  developer : Yi-Te Huang\nOther developers:\n    Simon Cross, Neill Lambert, Po-Chen Kuo and Shen-Liang Yang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nHierarchicalEOM    Ver. 2.4.2\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html",
    "href": "HierarchicalEOM.jl/electronic_current.html",
    "title": "Electronic Current",
    "section": "",
    "text": "Inspirations taken from qutip documentation."
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#introduction",
    "href": "HierarchicalEOM.jl/electronic_current.html#introduction",
    "title": "Electronic Current",
    "section": "Introduction",
    "text": "Introduction\nIn this example, we demonstrate how to compute an environmental observable: the electronic current. For further detailed discussions of calculating the electronic current using HierarchicalEOM.jl, we recommend to read the article (Huang et al. 2023)."
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#hamiltonian",
    "href": "HierarchicalEOM.jl/electronic_current.html#hamiltonian",
    "title": "Electronic Current",
    "section": "Hamiltonian",
    "text": "Hamiltonian\nWe consider a single-level charge system coupled to two [left (L) and right (R)] fermionic reservoirs (\\(\\textrm{f}\\)). The total Hamiltonian is given by \\(H_{\\textrm{T}}=H_\\textrm{s}+H_\\textrm{f}+H_\\textrm{sf}\\), where each terms takes the form\n\\[\n\\begin{aligned}\nH_{\\textrm{s}}  &= \\epsilon d^\\dagger d,\\\\\nH_{\\textrm{f}}  &=\\sum_{\\alpha=\\textrm{L},\\textrm{R}}\\sum_{k}\\epsilon_{\\alpha,k}c_{\\alpha,k}^{\\dagger}c_{\\alpha,k},\\\\\nH_{\\textrm{sf}} &=\\sum_{\\alpha=\\textrm{L},\\textrm{R}}\\sum_{k}g_{\\alpha,k}c_{\\alpha,k}^{\\dagger}d + g_{\\alpha,k}^* d^{\\dagger}c_{\\alpha,k}.\n\\end{aligned}\n\\]\nHere, \\(d\\) \\((d^\\dagger)\\) annihilates (creates) an electron in the system and \\(\\epsilon\\) is the energy of the electron. Furthermore, \\(c_{\\alpha,k}\\) \\((c_{\\alpha,k}^{\\dagger})\\) annihilates (creates) an electron in the state \\(k\\) (with energy \\(\\epsilon_{\\alpha,k}\\)) of the \\(\\alpha\\)-th reservoir.\nNow, we need to build the system Hamiltonian and initial state with the package QuantumToolbox.jl to construct the operators.\n\nusing HierarchicalEOM  # this automatically loads `QuantumToolbox`\nusing CairoMakie       # for plotting results\n\n\nd = destroy(2) # annihilation operator of the system electron\n\n# The system Hamiltonian\nϵ = 1.0 # site energy\nHsys = ϵ * d' * d\n\n# System initial state\nψ0 = basis(2, 0);"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#construct-bath-objects",
    "href": "HierarchicalEOM.jl/electronic_current.html#construct-bath-objects",
    "title": "Electronic Current",
    "section": "Construct bath objects",
    "text": "Construct bath objects\nWe assume the fermionic reservoir to have a Lorentzian-shaped spectral density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:\n\nthe coupling strength \\(\\Gamma\\) between system and reservoirs\nthe band-width \\(W\\)\nthe product of the Boltzmann constant \\(k\\) and the absolute temperature \\(T\\) : \\(kT\\)\nthe chemical potential \\(\\mu\\)\nthe total number of exponentials for the reservoir \\(2(N + 1)\\)\n\n\nΓ = 0.01\nW = 1\nkT = 0.025851991\nμL =  1.0 # Left  bath\nμR = -1.0 # Right bath\nN = 2\nbath_L = Fermion_Lorentz_Pade(d, Γ, μL, W, kT, N)\nbath_R = Fermion_Lorentz_Pade(d, Γ, μR, W, kT, N)\nbaths = [bath_L, bath_R]\n\n2-element Vector{FermionBath}:\n HierarchicalEOM.FermionBath object with 6 terms.\n\n HierarchicalEOM.FermionBath object with 6 terms."
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#construct-heomls-matrix",
    "href": "HierarchicalEOM.jl/electronic_current.html#construct-heomls-matrix",
    "title": "Electronic Current",
    "section": "Construct HEOMLS matrix",
    "text": "Construct HEOMLS matrix\n\ntier = 5\nM = M_Fermion(Hsys, tier, baths)\n\nPreparing block matrices for HEOM Liouvillian superoperator (using 4 threads)...\nProgress: [                              ]   0.1% --- Elapsed Time: 0h 00m 01s (ETA: 0h 26m 25s)Progress: [==============================] 100.0% --- Elapsed Time: 0h 00m 01s (ETA: 0h 00m 00s)\nConstructing matrix...[DONE]\n\n\nFermion type HEOMLS matrix acting on even-parity ADOs\nsystem dims = [2]\nnumber of ADOs N = 1586\ndata =\nMatrixOperator(6344 × 6344)"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#solve-time-evolution-of-ados",
    "href": "HierarchicalEOM.jl/electronic_current.html#solve-time-evolution-of-ados",
    "title": "Electronic Current",
    "section": "Solve time evolution of ADOs",
    "text": "Solve time evolution of ADOs\n\ntlist = 0:0.5:100\nados_evolution = HEOMsolve(M, ψ0, tlist).ados\n\nSolving time evolution for ADOs by Ordinary Differential Equations method...\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\n201-element Vector{ADOs}:\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n ⋮\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]\n\n 1586 Auxiliary Density Operators with even-parity and (system) dims = [2]"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#solve-stationary-state-of-ados",
    "href": "HierarchicalEOM.jl/electronic_current.html#solve-stationary-state-of-ados",
    "title": "Electronic Current",
    "section": "Solve stationary state of ADOs",
    "text": "Solve stationary state of ADOs\n\nados_steady = steadystate(M)\n\nSolving steady state for ADOs by linear-solve method...[DONE]\n\n\n1586 Auxiliary Density Operators with even-parity and (system) dims = [2]"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#calculate-current",
    "href": "HierarchicalEOM.jl/electronic_current.html#calculate-current",
    "title": "Electronic Current",
    "section": "Calculate current",
    "text": "Calculate current\nWithin the influence functional approach, the expectation value of the electronic current from the \\(\\alpha\\)-fermionic bath into the system can be written in terms of the first-level-fermionic (\\(n=1\\)) auxiliary density operators, namely\n\\[\n\\langle I_\\alpha(t) \\rangle =(-e) \\frac{d\\langle \\mathcal{N}_\\alpha\\rangle}{dt}=i e \\sum_{q\\in\\textbf{q}}(-1)^{\\delta_{\\nu,-}} ~\\textrm{Tr}\\left[d^{\\bar{\\nu}}\\rho^{(0,1,+)}_{\\vert \\textbf{q}}(t)\\right],\n\\]\nwhere \\(e\\) represents the value of the elementary charge, and \\(\\mathcal{N}_\\alpha=\\sum_k c^\\dagger_{\\alpha,k}c_{\\alpha,k}\\) is the occupation number operator for the \\(\\alpha\\)-fermionic bath.\nGiven an ADOs, we provide a function which calculates the current from the \\(\\alpha\\)-fermionic bath into the system with the help of Hierarchy Dictionary.\n\n# `bathIdx`:  \n# - 1 means 1st bath (bath_L)\n# - 2 means 2nd bath (bath_R)\nfunction Ic(ados, M::M_Fermion, bathIdx::Int)\n    # the hierarchy dictionary\n    HDict = M.hierarchy\n\n    # we need all the indices of ADOs for the first level\n    idx_list = HDict.lvl2idx[1]\n    I = 0.0im\n    for idx in idx_list\n        ρ1 = ados[idx]  # 1st-level ADO\n\n        # find the corresponding bath index (α) and exponent term index (k)\n        nvec = HDict.idx2nvec[idx]\n        for (α, k, _) in getIndexEnsemble(nvec, HDict.bathPtr)\n            if α == bathIdx\n                exponent = M.bath[α][k]\n                if exponent.types == \"fA\"     # fermion-absorption\n                    I += tr(exponent.op' * ρ1)\n                elseif exponent.types == \"fE\" # fermion-emission\n                    I -= tr(exponent.op' * ρ1)\n                end\n                break\n            end\n        end\n    end\n\n    eV_to_Joule = 1.60218E-19  # unit conversion\n\n    # (e / ħ) * I  [change unit to μA] \n    return 1.519270639695384E15 * real(1im * I) * eV_to_Joule * 1E6\nend\n\nIc (generic function with 1 method)"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#steady-current",
    "href": "HierarchicalEOM.jl/electronic_current.html#steady-current",
    "title": "Electronic Current",
    "section": "steady current",
    "text": "steady current\n\nIs_L = ones(length(tlist)) .* Ic(ados_steady, M, 1)\nIs_R = ones(length(tlist)) .* Ic(ados_steady, M, 2)\n\n201-element Vector{Float64}:\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n  ⋮\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624\n -0.04632854331413624"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#time-evolution-current",
    "href": "HierarchicalEOM.jl/electronic_current.html#time-evolution-current",
    "title": "Electronic Current",
    "section": "time evolution current",
    "text": "time evolution current\n\nIe_L = []\nIe_R = []\nfor ados in ados_evolution\n    push!(Ie_L, Ic(ados, M, 1))\n    push!(Ie_R, Ic(ados, M, 2))\nend\n\nplot the result\n\nfig = Figure(size = (500, 350))\nax = Axis(fig[1, 1], xlabel = \"time\", ylabel = \"Current\")\nlines!(ax, tlist, Ie_L, label = \"Bath L\", color = :blue, linestyle = :solid)\nlines!(ax, tlist, Ie_R, label = \"Bath R\", color = :red, linestyle = :solid)\nlines!(ax, tlist, Is_L, label = \"Bath L (Steady State)\", color = :blue, linestyle = :dash)\nlines!(ax, tlist, Is_R, label = \"Bath R (Steady State)\", color = :red, linestyle = :dash)\n\naxislegend(ax, position = :rt)\n\nfig"
  },
  {
    "objectID": "HierarchicalEOM.jl/electronic_current.html#version-information",
    "href": "HierarchicalEOM.jl/electronic_current.html#version-information",
    "title": "Electronic Current",
    "section": "Version Information",
    "text": "Version Information\n\nHierarchicalEOM.versioninfo()\n\n\n                                   __\n                                  /  \\\n __     __                     __ \\__/ __\n|  |   |  |                   /  \\    /  \\\n|  |   |  | ______   ______   \\__/_  _\\__/\n|  |___|  |/  __  \\ /  __  \\ / '   \\/     \\\n|   ___   |  |__)  |  /  \\  |    _     _   |\n|  |   |  |   ____/| (    ) |   / \\   / \\  |\n|  |   |  |  |____ |  \\__/  |  |   | |   | |\n|__|   |__|\\______) \\______/|__|   |_|   |_|\n\nJulia framework for Hierarchical Equations of Motion\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2023 and later.\nLead  developer : Yi-Te Huang\nOther developers:\n    Simon Cross, Neill Lambert, Po-Chen Kuo and Shen-Liang Yang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nHierarchicalEOM    Ver. 2.4.2\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/lowrank.html",
    "href": "QuantumToolbox.jl/time_evolution/lowrank.html",
    "title": "Low rank master equation",
    "section": "",
    "text": "In this tutorial we will demonstrate how to solve the master equation without the quadratic overhead associated with the full manipulation of the density matrix. For a detailed explanation of the method, we recommend to read the Ref. (Gravina and Savona 2024).\nThe proposed approach is based on the realization that many quantum systems, particularly those with low entropy, can be effectively represented by a density matrix of significantly lower rank than what the whole Hilbert space would require. This reduction is achieved by focusing on a subset of states that capture the essential structure of the statistical ensemble characterizing the mixed quantum state, thereby reducing computational complexity while maintaining the exactness of the method.\n\n\nWe consider a decomposition of the density matrix of the form \\[\n    \\hat\\rho(t) = \\sum_{i,j=1}^{M(t)} B_{i,j}(t) | \\varphi_i(t) \\rangle \\langle \\varphi_j(t) |.\n\\] The states \\(\\{|\\varphi_k(t)\\rangle\\,;\\,k=1,\\ldots,M(t)\\}\\) spanning the low-rank manifold, can in turn be decomposed as \\[\n    |\\varphi_k(t)\\rangle = \\sum_{\\alpha=1}^{N} z_{\\alpha,k}(t) |e_\\alpha\\rangle,\n\\] where \\(\\{|e_\\alpha\\rangle\\,;\\,\\alpha=1,\\ldots,N\\}\\) is a fixed basis of the Hilbert space, and \\(z_{\\alpha,k}(t)\\) are the time-dependent coefficients.\nThe coefficients \\(B_{i,j}(t)\\) are collected in the matrix \\(B(t)\\), and the coefficients \\(z_{\\alpha,k}(t)\\) are collected in the matrix \\(z(t)\\).\nIn (Gravina and Savona 2024) all coefficients \\(B_{i,j}(t)\\) and \\(z_{\\alpha,k}(t)\\) are taken to be variational parameters. The evolution equation for the density matrix is consequently mapped onto a set of differential equations for such parameters via the time-dependent variational principle (TDVP).\nThe TDVP ensures a dynamical adjustment of the variational states, guaranteeing the optimal set of states is selected at all times to best approximate the dissipative evolution. This allows for a significant reduction in computational complexity as the number of states \\(M(t)\\) necessary to accurately capture the dynamics of the system is as small as can be, hopefully much smaller than the full Hilbert space dimension \\(N\\)."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/lowrank.html#introduction",
    "href": "QuantumToolbox.jl/time_evolution/lowrank.html#introduction",
    "title": "Low rank master equation",
    "section": "",
    "text": "In this tutorial we will demonstrate how to solve the master equation without the quadratic overhead associated with the full manipulation of the density matrix. For a detailed explanation of the method, we recommend to read the Ref. (Gravina and Savona 2024).\nThe proposed approach is based on the realization that many quantum systems, particularly those with low entropy, can be effectively represented by a density matrix of significantly lower rank than what the whole Hilbert space would require. This reduction is achieved by focusing on a subset of states that capture the essential structure of the statistical ensemble characterizing the mixed quantum state, thereby reducing computational complexity while maintaining the exactness of the method.\n\n\nWe consider a decomposition of the density matrix of the form \\[\n    \\hat\\rho(t) = \\sum_{i,j=1}^{M(t)} B_{i,j}(t) | \\varphi_i(t) \\rangle \\langle \\varphi_j(t) |.\n\\] The states \\(\\{|\\varphi_k(t)\\rangle\\,;\\,k=1,\\ldots,M(t)\\}\\) spanning the low-rank manifold, can in turn be decomposed as \\[\n    |\\varphi_k(t)\\rangle = \\sum_{\\alpha=1}^{N} z_{\\alpha,k}(t) |e_\\alpha\\rangle,\n\\] where \\(\\{|e_\\alpha\\rangle\\,;\\,\\alpha=1,\\ldots,N\\}\\) is a fixed basis of the Hilbert space, and \\(z_{\\alpha,k}(t)\\) are the time-dependent coefficients.\nThe coefficients \\(B_{i,j}(t)\\) are collected in the matrix \\(B(t)\\), and the coefficients \\(z_{\\alpha,k}(t)\\) are collected in the matrix \\(z(t)\\).\nIn (Gravina and Savona 2024) all coefficients \\(B_{i,j}(t)\\) and \\(z_{\\alpha,k}(t)\\) are taken to be variational parameters. The evolution equation for the density matrix is consequently mapped onto a set of differential equations for such parameters via the time-dependent variational principle (TDVP).\nThe TDVP ensures a dynamical adjustment of the variational states, guaranteeing the optimal set of states is selected at all times to best approximate the dissipative evolution. This allows for a significant reduction in computational complexity as the number of states \\(M(t)\\) necessary to accurately capture the dynamics of the system is as small as can be, hopefully much smaller than the full Hilbert space dimension \\(N\\)."
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/lowrank.html#low-rank-dynamics-of-the-transverse-field-heisenberg-model",
    "href": "QuantumToolbox.jl/time_evolution/lowrank.html#low-rank-dynamics-of-the-transverse-field-heisenberg-model",
    "title": "Low rank master equation",
    "section": "Low-rank dynamics of the transverse field Heisenberg model",
    "text": "Low-rank dynamics of the transverse field Heisenberg model\nIn this example we consider the dynamics of the transverse field Ising model (TFIM) on a 2x3 lattice. We start by importing the packages\n\nusing QuantumToolbox\nusing CairoMakie\n\nWe define the lattice with dimensions Nx = 2 and Ny = 3 and use the Lattice class to generate the lattice.\n\nNx, Ny = 2, 3\nlatt = Lattice(Nx = Nx, Ny = Ny)\n\nLattice{Int64, LinearIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}}(2, 3, 6, [1 3 5; 2 4 6], CartesianIndices((2, 3)))\n\n\nThe Hamiltonian of the TFIM reads \\[\nH = J_x \\sum_{\\langle i,j \\rangle} \\sigma_i^x \\sigma_j^x + J_y \\sum_{\\langle i,j \\rangle} \\sigma_i^y \\sigma_j^y + J_z \\sum_{\\langle i,j \\rangle} \\sigma_i^z \\sigma_j^z + h_x \\sum_i \\sigma_i^x,\n\\] where $ _i^{x,y,z} $ are the Pauli matrices acting on site $ i $ and $ i,j $ denotes nearest neighbors. The collapse operators are given by \\[\nc_i = \\sqrt{\\gamma} \\sigma_i^-,\n\\] where $ _i^- $ is the lowering operator acting on site $ i$. The many-body operators are constructed using\n\nJx = 0.9\nJy = 1.04\nJz = 1.0\nhx = 0.0\nγ = 1\n\nSx = mapreduce(i-&gt;MultiSiteOperator(latt, i =&gt; sigmax()), +, 1:latt.N)\nSy = mapreduce(i-&gt;MultiSiteOperator(latt, i =&gt; sigmay()), +, 1:latt.N)\nSz = mapreduce(i-&gt;MultiSiteOperator(latt, i =&gt; sigmaz()), +, 1:latt.N)\n\nSFxx = sum([MultiSiteOperator(latt, i =&gt; sigmax()) * MultiSiteOperator(latt, j =&gt; sigmax()) for i in 1:latt.N for j in 1:latt.N])\n\nH, c_ops = DissipativeIsing(Jx, Jy, Jz, hx, 0., 0., γ, latt; boundary_condition=:periodic_bc, order=1)\ne_ops = (Sx, Sy, Sz, SFxx)\n\ntl = LinRange(0, 10, 100);\n\n\nConstructing the low-rank basis\nWe proceed by constructing the low-rank basis. N_cut is the dimension of the Hilbert space of each mode, and N_modes is the number of modes (or spins). We consider an initial low-rank basis with M = Nx * Ny + 1 states.\nWe first define the lr-space dimensions\n\nN_cut = 2 # Number of states of each mode\nN_modes = latt.N  # Number of modes\nN = N_cut^N_modes # Total number of states\n\nM = latt.N + 1; # Number of states in the LR basis\n\nSince we will take as initial state for our dynamics the pure state with all spins pointing up, the initial low-rank basis must include at least this state.\n\nϕ = Vector{QuantumObject{KetQuantumObject,Dimensions{M - 1,NTuple{M - 1,Space}},Vector{ComplexF64}}}(undef, M)\nϕ[1] = kron(fill(basis(2, 1), N_modes)...)\n\n\nQuantum Object:   type=Ket   dims=[2, 2, 2, 2, 2, 2]   size=(64,)\n64-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n     ⋮\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n\n\nThe remaining M-1 states are taken as those with minimal Hamming distance from the latter state, that is those we obtain by flipping the spin of a single site with respect to the completely polarized state.\n\ni = 1\nfor j in 1:N_modes\n    global i += 1\n    i &lt;= M && (ϕ[i] = MultiSiteOperator(latt, j=&gt;sigmap()) * ϕ[1])\nend\n\nfor k in 1:N_modes-1\n    for l in k+1:N_modes\n        global i += 1\n        i &lt;= M && (ϕ[i] = MultiSiteOperator(latt, k=&gt;sigmap(), l=&gt;sigmap()) * ϕ[1])\n    end\nend\n\nAt this point the vector of states ϕ contains the full representation of our low-rank states. These coefficients comprise matrix z.\nThe matrix B, on the other hand, contains the populations and coherences with which each of the low-rank states contributes to the density matrix. We initialize it so that only the first state is populated, and all other states are unpopulated.\nWe also compute the full density matrix ρ from the low-rank representation. Of course this defeats the purpose of the low-rank representation. We use it here for illustrative purposes to show that the low-rank predictions match the exact dynamics.\n\nz = hcat(get_data.(ϕ)...)\nB = Matrix(Diagonal([1 + 0im; zeros(M - 1)]))\nS = z' * z # Overlap matrix\nB = B / tr(S * B) # Normalize B\n\nρ = QuantumObject(z * B * z', dims = ntuple(i-&gt;N_cut, Val(N_modes))); # Full density matrix\n\n\n\nFull evolution\nWe now compare the results of the low-rank evolution with the full evolution. We first evolve the system using the mesolve function\n\nsol_me = mesolve(H, ρ, tl, c_ops; e_ops = [e_ops...])\nStrue = entropy_vn(sol_me.states[end], base=2) / latt.N;\n\nProgress: [==============================] 100.0% --- Elapsed Time: 0h 00m 00s (ETA: 0h 00m 00s)\n\n\n\n\nLow Rank evolution\nThe lr_mesolve function allows to conveniently keep track of non-linear functionals of the density matrix during the evolution without ever computing the full density matrix and without the need to store z and B at each time step. To do so we define the functionals of the density matrix that we want to keep track of and that will be evaluated at each time step.\nWe compute the purity \\[\nP = \\mathrm{Tr}(\\rho^2),\n\\] the von Neumann entropy \\[\nS = -\\mathrm{Tr}(\\rho \\log_2(\\rho)),\n\\] and the trace \\[\n\\mathrm{Tr}(\\rho).\n\\]\nTo maximize efficiency and minimize memory allocations we make use of preallocated variables stores in the parameters constructor of the solver.\n\nfunction f_purity(p, z, B)\n    N = p.N\n    M = p.M\n    S = p.S\n    T = p.temp_MM\n\n    mul!(T, S, B)\n    return tr(T^2)\nend\n\nfunction f_trace(p, z, B)\n    N = p.N\n    M = p.M\n    S = p.S\n    T = p.temp_MM\n\n    mul!(T, S, B)\n    return tr(T)\nend\n\nfunction f_entropy(p, z, B)\n    C = p.A0\n    σ = p.Bi\n\n    mul!(C, z, sqrt(B))\n    mul!(σ, C', C)\n    return entropy_vn(Qobj(Hermitian(σ), type=Operator), base=2)\nend;\n\nA critical aspect of the LR truncation is the possibility to dynamically adjust the dimension of the basis throughout the system’s evolution \\(M=M(t)\\). This adaptability is essential for accommodating changes in the system’s entropy over time.\nTo adapt the dimension of the low-rank basis, we look at a control parameter \\(\\chi\\) that is positively correlated with the entropy of the system and provides a measure of the quality of the low-rank approximation. When \\(\\chi\\) exceeds a certain threshold, the dimension of the low-rank basis is increased by one.\nThe options below specify how the dimension of the low-rank basis is adjusted during the evolution.\n\nopt = (err_max = 1e-3, p0 = 0.0, atol_inv = 1e-6, adj_condition = \"variational\", Δt = 0.0);\n\nerr_max is the maximum error allowed in the time evolution of the density matrix.\np0 is the initial population with which the new state is added to the basis after crossing the threshold.\nadj_condition = \"variational\" selects one of three possible definitions for the control quantity chi. Specifically, the selected option consists in the leakage from the variational manifold and is defined as \\[\n\\chi = \\operatorname{Tr}(S^{-1} L).\n\\]\nFinally, Δt specifies the checkpointing interval by which the simulation is rewinded upon the basis expansion.\nNot directly related to the basis expansion, but still important for the stability of the algorithm, are the options atol_inv (the tolerance for the inverse of the overlap matrix) and alg (the ODE solver).\nWe now launch the evolution using the lr_mesolve function\n\nsol_lr = lr_mesolve(H, z, B, tl, c_ops; e_ops = e_ops, f_ops = (f_purity, f_entropy, f_trace), opt = opt);\n\nProgress: 2%Progress: 3%Progress: 4%Progress: 5%Progress: 6%Progress: 7%Progress: 8%Progress: 9%Progress: 10%Progress: 11%Progress: 12%Progress: 13%Progress: 14%Progress: 15%Progress: 16%Progress: 17%Progress: 18%Progress: 19%Progress: 20%Progress: 21%Progress: 22%Progress: 23%Progress: 24%Progress: 25%Progress: 26%Progress: 27%Progress: 28%Progress: 29%Progress: 30%Progress: 31%Progress: 32%Progress: 33%Progress: 34%Progress: 35%Progress: 36%Progress: 37%Progress: 38%Progress: 39%Progress: 40%Progress: 41%Progress: 42%Progress: 43%Progress: 44%Progress: 45%Progress: 46%Progress: 47%Progress: 48%Progress: 49%Progress: 50%Progress: 51%Progress: 52%Progress: 53%Progress: 54%Progress: 55%Progress: 56%Progress: 57%Progress: 58%Progress: 59%Progress: 60%Progress: 61%Progress: 62%Progress: 63%Progress: 64%Progress: 65%Progress: 66%Progress: 67%Progress: 68%Progress: 69%Progress: 70%Progress: 71%Progress: 72%Progress: 73%Progress: 74%Progress: 75%Progress: 76%Progress: 77%Progress: 78%Progress: 79%Progress: 80%Progress: 81%Progress: 82%Progress: 83%Progress: 84%Progress: 85%Progress: 86%Progress: 87%Progress: 88%Progress: 89%Progress: 90%Progress: 91%Progress: 92%Progress: 93%Progress: 94%Progress: 95%Progress: 96%Progress: 97%Progress: 98%Progress: 99%Progress: 100%\n\n\nWe can now compare the results of the low-rank evolution with the full evolution.\n\nm_me = real(sol_me.expect[3, :]) / Nx / Ny\nm_lr = real(sol_lr.expect[3, :]) / Nx / Ny\n\nfig = Figure(size = (500, 350), fontsize = 15)\nax = Axis(fig[1, 1], xlabel = L\"\\gamma t\", ylabel = L\"M_{z}\", xlabelsize = 20, ylabelsize = 20)\nlines!(ax, tl, m_lr, label = L\"LR $[M=M(t)]$\", linewidth = 2)\nlines!(ax, tl, m_me, label = \"Fock\", linewidth = 2, linestyle = :dash)\naxislegend(ax, position = :rb)\n\nax2 = Axis(fig[1, 2], xlabel = L\"\\gamma t\", ylabel = \"Value\", xlabelsize = 20, ylabelsize = 20)\nlines!(ax2, tl, 1 .- real(sol_lr.fexpect[1, :]), label = L\"$1-P$\", linewidth = 2)\nlines!(\n    ax2,\n    tl,\n    1 .- real(sol_lr.fexpect[3, :]),\n    label = L\"$1-\\mathrm{Tr}(\\rho)$\",\n    linewidth = 2,\n    linestyle = :dash,\n    color = :orange,\n)\nlines!(ax2, tl, real(sol_lr.fexpect[2, :]) / Nx / Ny, color = :blue, label = L\"S\", linewidth = 2)\nhlines!(ax2, [Strue], color = :blue, linestyle = :dash, linewidth = 2, label = L\"S^{\\,\\mathrm{true}}_{\\mathrm{ss}}\")\naxislegend(ax2, position = :rb)\n\nfig"
  },
  {
    "objectID": "QuantumToolbox.jl/time_evolution/lowrank.html#version-information",
    "href": "QuantumToolbox.jl/time_evolution/lowrank.html#version-information",
    "title": "Low rank master equation",
    "section": "Version Information",
    "text": "Version Information\n\nQuantumToolbox.versioninfo()\n\n\n QuantumToolbox.jl: Quantum Toolbox in Julia\n≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\nCopyright © QuTiP team 2022 and later.\nCurrent admin team:\n    Alberto Mercurio and Yi-Te Huang\n\nPackage information:\n====================================\nJulia              Ver. 1.11.3\nQuantumToolbox     Ver. 0.25.2\nSciMLOperators     Ver. 0.3.12\nLinearSolve        Ver. 2.39.0\nOrdinaryDiffEqCore Ver. 1.15.1\n\nSystem information:\n====================================\nOS       : Linux (x86_64-linux-gnu)\nCPU      : 4 × AMD EPYC 7763 64-Core Processor\nMemory   : 15.615 GB\nWORD_SIZE: 64\nLIBM     : libopenlibm\nLLVM     : libLLVM-16.0.6 (ORCJIT, znver3)\nBLAS     : libopenblas64_.so (ilp64)\nThreads  : 4 (on 4 virtual cores)"
  }
]